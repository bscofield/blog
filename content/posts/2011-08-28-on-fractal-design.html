---
date: 2011-08-28
layout: post
title: On Fractal Design
published: true
---
<p class="p1">I'm on my way back home after a great&nbsp;<a href="http://rubyhoedown.com/"><span class="s1">Ruby Hoedown</span></a>&nbsp;in Nashville, where I gave a talk called "Fractal Design." This is the second(ish) time I've given this talk, having previewed it in a very conversational format at the Charlotte Ruby Users' Group a month or so ago -- but I'm starting to think it's better suited for a blog post (or series of, at least), so: this.</p>
<p class="p1">The idea behind the talk is that, just as fractals are the immensely complex, impressive, and emergent results of the repeated application of a simple set of rules at different levels of magnification, so to might we produce complex and impressive software by repeatedly applying a simple set of principles and practices at different levels of code.</p>
<p class="p1"><span style="font-size: medium;"><strong>The Sierpinski Triangle</strong></span></p>
<p class="p1">So most people have probably seen the&nbsp;<span class="s2"><a href="http://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski Triangle</a></span>&nbsp;at some point. Heck, I bet more of them have been idly doodled in middle school math notebooks than were ever generated by practicing mathematicians.</p>
<p class="p1">The basic idea is that you start with an equilateral triangle.&nbsp;</p>
<p>[[posterous-content:qqaBCIfkrcwkaAzcfnxz]]</p>
<p class="p1">You then remove the triangle formed by connecting the midpoints of each side, leaving you with three new triangles:</p>
<p class="p1">[[posterous-content:BaoHohnEhsbpuFfgldps]]</p>
<p class="p1">Next, you do the same thing to each of these three triangles -- remove smaller triangles from the center of each:</p>
<p>[[posterous-content:bvasmbCqDaAcxkJmIBqi]]</p>
<p class="p1">And on and on, as many times as you like.</p>
<p class="p1">[[posterous-content:ioBFJyFkDwvhcbbuvwof]]</p>
<p class="p1">What you end up with is impossibly intricate, and can be manipulated in surprising ways. When conceived of in three dimensions, you end up with a structure that has an infinite surface area and no volume at all! (a pyramidal&nbsp;<a href="http://en.wikipedia.org/wiki/Menger_sponge"><span class="s1">Menger sponge</span></a>)</p>
<p class="p1"><span style="font-size: medium;"><strong>Software</strong></span></p>
<p class="p1">OK, so software isn't exactly <span style="font-size: small;">analogous</span> to pure geometric space. Nevertheless, we do have distinct levels of magnification:</p>
<p class="p1">methods &rarr; classes &rarr; libraries &rarr; applications &rarr; ecosystems</p>
<p class="p1">We also have a large array of software design principles and practices, each of which is usually couched in the language of one of these levels (or at most, two adjacent levels). The <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID principles</a>, <a href="http://en.wikipedia.org/wiki/Extreme_programming_practices">XP's practices</a>, the <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">law of Demeter</a>, <a href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science)">design patterns</a> -- what would happen if we tried applying them across our entire body of software, instead of just when designing a library's API, a user interface, or a single method?</p>
<p class="p1">So that's the question. In future posts I'll tackle this question with specific principles, and hopefully we'll find something interesting.</p>
<p>&nbsp;</p>
